CBMC-GC v2.0alpha


OVERVIEW
========

This release contains CBMC-GC and ShallowCC to compile size or depth optimized
circuits for MPC from ANSI-C. Moreover, it contains various tools, scripts, and
examples to experiment with the created circuits, and a parser for the ABY [1]
framework. 
This README covers most of the features of this release, a detailed documentation
of CBMC-GC can be found here [2]. ShallowCC is described in paper [3].

 * [1] https://github.com/encryptogroup/ABY
 * [2] http://forsyte.at/software/cbmc-gc/
 * [3] Niklas BÃ¼scher, Andreas Holzer, Alina Weber, Stefan Katzenbeisser: 
Compiling Low Depth Circuits for Practical Secure Computation. ESORICS (2) 2016


Compiling the Compiler
======================

Simply run

    make minisat2-download
    make


Compiling Circuits
==================

Example programs are given in examples/ and can be compiled with make.
Please have a look at the detailed documentation and paper listed at [2].
Make sure that your program is using CBMC-GC's i/o variable notation and
that the program is bound (loops/recursion) or specify an upper bound for
the loop unrolling:
  --unwind X
 where X is the upper bound on unrolling loops. To limit the circuit
 minimization phase please use (this is essential for large programs!):
  --minimization-time-limit X
where X is an integer value in seconds. To compile circuits with minimal
depth (ShallowCC) add the following flag:
  --low-depth

Note that the (depth) reduction preprocessing step described in [3] is
not contained in this release. Sequential arithmetics are compressed when
written in a single expression (t = a * b + c)!


Running circuits
================

The `circuit-sim` utility allows to evaluate (simulate) circuits in the clear.
First, `cd` into the directory of the compiled circuit (i.e., the directory with
lots of `output.\*.txt` files). If the circuit takes two integers as input, you can run
the `circuit-sim` command and specify the value of the input varibles:

    circuit-sim --spec "INPUT_A := 42; INPUT_B := 99; print;"

This will execute the circuit and then print the values of all input and output
variables.

Arrays can be specified with `[1, 2, 3]` and structs with `{a: 23; b: 48;}`
(don't forget the semicolon after the last attribute).

You can also specify assertions:

    circuit-sim --spec "INPUT_A := 42; INPUT_B := 99; return_value == 141;"

This will print a error message if the output of the circuit is not 141.

Multiple runs of a circuit can be specified in a file.

    INPUT_A := 42;
    INPUT_B := 99;
    return_value == 141;
    ---
    INPUT_A := 100;
    INPUT_B := 200;
    return_value == 300;

If the above is saved to `test.spec` it can be run like so:

    circuit-sim --spec-file test.spec


Secure Two-Party Computation with ABY (OUTDATED DUE TO CHANGE IN ABY API)
========================================================================

To use a generated circuit with ABY you need to:

1. Clone and build the ABY framework (follow the instructions on
   <https://github.com/encryptogroup/ABY>). The framework needs to be put next
   to the `cbmc-gc/` folder (i.e. one directory up relative to this readme).
2. Copy the folder `aby-cbmc-gc/` to `ABY/src/examples/`.
3. Run `make` in the top-level directory of the ABY framework.
4. `ABY/bin/` should now contain another binary called `aby-cbmc-gc.exe`.

To use `aby-cbmc-gc.exe` you first need to `cd` into the directoty containing
the circuit files.

Example usage:

    aby-cbmc-gc.exe -r 0 --spec "INPUT_B := 36;" &
    aby-cbmc-gc.exe -r 1 --spec "INPUT_A := 23;"

The option `-r 0` starts `aby-cbmc-gc.exe` as a server and `-r 1` as a client.

Inputs starting with `INPUT_B` are associated with the server and the ones
starting with `INPUT_A` with the client.


Export to other formats
=======================

You can use `circuit-utils` to convert a circuit generated by CBMC-GC to another
format.

Currently supported export options:

- `--as-bristol`: Bristol format (<https://www.cs.bris.ac.uk/Research/CryptographySecurity/MPC/>).
  Note that currently it is not possible to use the Bristol format for circuits
  that directly connect input gates to output gates.
- `--as-shdl`: Fairplay's SHDL format.
- `--as-scd`: justGarble's Simple Circuit Descrition format.

Example: Go to the directory that contains the circuit generated by CBMC-GC.
Then run

    circuit-utils --as-bristol bristol_circuit.txt

to convert the circuit to the Bristol format. If your framework is only
supporting AND, XOR and NOT gates (e.g., the EMP-toolkit), use

    circuit-utils --remove-or-gates --as-bristol bristol_circuit.txt 


Tests
=====

Building all tests: `make test`.

Running all tests: `make run-test`.

The above commands will create two copies of `test-src/`: `test-default/` and
`test-lowdepth/`. The only difference between them is that the tests in
`test-lowdepth/` will be compiled using `--low-depth`.

The basic idea is that `test-src/` contains only the source files of the tests
and that copies of the whole directory are made for each specific set of
command-line options to `cbmc-gc`. So do not run `make` directly in `test-src`
but only in copies of it.

For example, to test `cbmc-gc` with depth-optimization enabled you would copy
`test-src/` to e.g. `test-lowdepth/` and append `--low-depth` to
`test-lowdepth/CBMC_GC_FLAGS`. Then you would `cd` into `test-lowdepth` and run
`make run` to compile and execute all tests. (Note that this specific test-case
will be created by default so you don't need to actually do it.)

You can also build or run individual tests. Example: From a test directory
(e.g. `test-default/`) run:

    make build-addition_int32
    make run-addition_int32

This will first build and then run the test-case `addition_int32`.


Comparing test results
----------------------

To get a quick overview of the number of non-XOR gates of each test use
`testcmp` to generate a HTML table:

    ./testcmp test-default test-lowdepth > comparison.html

This will create a table containing the results from the directories
`test-default/` and `test-lowdepth/` and write it to `comparison.html`.
You can specify an arbitrary number of test directories to compare.


Differential testing:
---------------------

CBMC-GC has built support for differential testing of c code against
circuits. There are currently two possible ways to test a circuit: (1)
you can create a test-runner that generates random inputs and compares
the output of the circuit with the output of the original C version or
(2) you can *verify* that the circuit behaves exactly the same as the
C code. Whether you can use (2) depends on the complexity of the
circuit: if the circuit contains no multiplication or division then you
are often fine. 8-bit multiplication/division shouldn't cause any
problems either, but anything more is probably too much.

To generate a random-input test-runner, execute the following in the same
directory as the compiled circuit:

    circuit-utils --create-tester tester.cpp --reference reference.c

where `reference.c` must contain the C code of the circuit. The output is C++
file which, when compiled and executed, will test the circuit and output any
values that differ from the output of the C version.

To create a verifier, run:

    circuit-utils --create-verifier verifier.c --reference reference.c

The resulting `verifier.c` file can then be fed into `cbmc`:

    cbmc verifier.c

If the verification is successful then the circuit should be equivalent to the C
code.

NOTE: Currently, creating tests poses some restrictions on the C code:

    1. The circuit must have exactly two inputs variables (one for each party).
       If a party must provide data in more than one variable put them in a
       struct.
    2. The types of `INPUT_A`, `INPUT_B` and of the ouput variable must be named
       `InputA`, `InputB` and `Output`, respectively.

Take a look at the test-cases for examples.

